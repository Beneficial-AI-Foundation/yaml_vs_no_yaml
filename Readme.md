### "no_yaml" contains:
(1) the original lean code "verina_advanced_15_original.lean"
(2) the verus code generated by Claude from (1) "verina_advanced_15_lean_to_verus.rs"
(3) the verus spec generated by removing body functions (see [details](https://github.com/Beneficial-AI-Foundation/generate_verus_specs/blob/master/README.md#-function-body-removal))
(4) the verus implementation generated by Claude (`spec_to_code.py`) for (3); this one verifies

 
### "yaml" contains:
(1) the lean spec "verina_advanced_15_task.lean" from the vericoding benchmark
(2) the verus spec generated by Claude from (1) "verina_advanced_15_task.rs"
(3) the verus implementation generated by Claude (`spec_to_code.py`) for (2); this one doesn't verify

### no_yaml vs yaml

The spec in "no_yaml" approach differs from the one in "yaml" in that it contains a helper "loop_search" which comes from the original lean transpilation (see `let rec loop` in "verina_advanced_15_original.lean"). With this helper, Claude managed to find a correct implementation. 

This is just one example, but i suspect we can make the observation that:
- the lean specs in "vericoding/benchmarks/lean/verina" "lose" the helper functions; the more informative a spec, the easier for Claude to find an implementation. 


