This repository compares two different approaches to generating Verus specifications and implementations from Lean code, specifically for the `verina_advanced_15` example.

## Directory Structure

### `no_yaml/` Directory

Contains files generated using the direct Lean-to-Verus transpilation approach:

1. **`verina_advanced_15_original.lean`** - The original Lean code
2. **`verina_advanced_15_lean_to_verus.rs`** - Verus code generated by Claude from the original Lean
3. **`verina_advanced_15.rs`** - Verus spec generated by removing function bodies (see [function body removal details](https://github.com/Beneficial-AI-Foundation/generate_verus_specs/blob/master/README.md#-function-body-removal))
4. **`verina_advanced_15_impl.rs`** - Verus implementation generated by Claude using `spec_to_code.py` ✅ **This implementation verifies successfully**

### `yaml/` Directory

Contains files generated using the vericoding benchmark approach:

1. **`verina_advanced_15_task.lean`** - Lean spec from the vericoding benchmark
2. **`verina_advanced_15_task.rs`** - Verus spec generated by Claude from the benchmark Lean
3. **`verina_advanced_15_task_impl.rs`** - Verus implementation generated by Claude using `spec_to_code.py` ❌ **This implementation does not verify**

## Differences and Observations

The main difference between the two approaches lies in the **preservation of helper functions**:

- **`no_yaml` approach**: Retains the helper function `loop_search` from the original Lean transpilation (derived from `let rec loop` in `verina_advanced_15_original.lean`)
- **`yaml` approach**: The vericoding benchmark specs omit these helper functions

I assume that the more informative a specification, the easier it is for Claude to find a correct implementation.

The Lean specs in `vericoding/benchmarks/lean/verina` appear to "lose" helper functions during the benchmark creation process, making them less informative and harder to implement correctly.


